from pydantic import BaseModel, Field, model_validator, ConfigDict
from typing import List, Optional, Dict, Any, ClassVar, Union, Literal
from uuid import UUID
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

# --- Location and World Structures ---

class Coordinates(BaseModel):
    latitude: Optional[float] = None
    longitude: Optional[float] = None

class Location(BaseModel):
    city: Optional[str] = None
    state: Optional[str] = None
    country: Optional[str] = None
    coordinates: Coordinates = Field(default_factory=Coordinates)

class WorldRules(BaseModel):
    allow_teleportation: bool = False
    time_progression_rate: float = 1.0
    weather_effects_travel: bool = True
    historical_date: Optional[str] = None # Keep as string for now, consider datetime parsing later

class WorldConfig(BaseModel):
    world_instance_uuid: UUID
    world_type: str
    sub_genre: Optional[str] = None
    description: Optional[str] = None
    rules: WorldRules = Field(default_factory=WorldRules)
    location: Location = Field(default_factory=Location)
    setup_timestamp_utc: str # Keep as string for now

# --- Simulacra Structures ---
# Based on expected output from life_generator and potential state

class PersonaDetails(BaseModel):
    # Define fields based on what life_generator actually produces
    # Example fields:
    Name: str = "Unknown"
    Age: Optional[int] = None
    Gender: Optional[str] = None
    Occupation: Optional[str] = None
    
    model_config = ConfigDict(extra="allow") # Changed from "allow"

class SimulacraState(BaseModel):
    simulacra_id: str
    world_instance_uuid: UUID # Crucial for linking
    persona_details: PersonaDetails = Field(default_factory=PersonaDetails)
    current_mood: Optional[str] = "neutral" # Add mood field, default to neutral
    # Add other top-level fields from life_summary.json (goals, memories, status, etc.)
    # Use 'Any' or specific types/models if known
    memories: List[Any] = Field(default_factory=list)
    goals: List[Any] = Field(default_factory=list)
    current_status: Optional[str] = None
    
    model_config = ConfigDict(extra="allow") # Changed from "allow"

# --- Overall Simulation State ---

class SimulationState(BaseModel):
    world_config: WorldConfig
    simulacra: List[SimulacraState] = Field(default_factory=list)
    # Add other dynamic state elements if needed (e.g., current_time)
    current_simulation_time: Optional[datetime] = None

# --- Added from simulation_async.py ---
class ScheduledFutureEvent(BaseModel):
    event_type: str
    target_agent_id: Optional[str] = None
    location_id: str
    details: Dict[str, Any] = Field(default_factory=dict)
    estimated_delay_seconds: float

    model_config = ConfigDict(extra="allow")

# --- World Engine Specific Discovery Models ---
# These models are specifically for the output of the World Engine when it resolves an action.
class WEDiscoveredObject(BaseModel):
    id: str = Field(..., description="Unique ID for the discovered object (e.g., 'shiny_red_apple', 'old_book_01'). Should be descriptive and unique within the location.")
    name: str = Field(..., description="Display name of the object (e.g., 'Shiny Red Apple', 'Old Dusty Book').")
    description: Optional[str] = Field(None, description="A brief description of the object's appearance or nature.")
    # Example: is_interactive: bool = Field(False, description="Can this object be directly interacted with beyond observation?")
    # Add other fields relevant from the World Engine's perspective of an object.

class WEDiscoveredNPC(BaseModel):
    id: str = Field(..., description="Unique ID for the discovered NPC (e.g., 'mysterious_stranger_01', 'shopkeeper_bob').")
    name: str = Field(..., description="Display name of the NPC (e.g., 'Mysterious Stranger', 'Shopkeeper Bob').")
    description: Optional[str] = Field(None, description="A brief description of the NPC's appearance or demeanor.")
    # Add other fields relevant from the World Engine's perspective of an NPC.

class WEDiscoveredConnection(BaseModel):
    to_location_id_hint: str = Field(..., description="The ID hint for the location this connection leads to (e.g., 'kitchen', 'street_corner_shop'). This ID will be used if the location needs to be generated by the WorldGeneratorAgent.")
    description: Optional[str] = Field(None, description="A brief description of the connection (e.g., 'A narrow hallway leading to the kitchen', 'A bustling doorway to the street corner shop').")
    # Add other fields like travel_time_estimate, locked_status, etc.

class WorldEngineResponse(BaseModel):
    valid_action: bool
    duration: float = Field(ge=0.0)
    results: Dict[str, Any] = Field(default_factory=dict)  # Allow any values
    outcome_description: str
    scheduled_future_event: Optional[ScheduledFutureEvent] = None
    discovered_objects: Optional[List[WEDiscoveredObject]] = Field(None, description="A list of objects discovered or made apparent by this action in the current location, as determined by the World Engine.")
    discovered_npcs: Optional[List[WEDiscoveredNPC]] = Field(None, description="A list of NPCs discovered or encountered due to this action in the current location, as determined by the World Engine.")
    discovered_connections: Optional[List[WEDiscoveredConnection]] = Field(None, description="A list of new connections/exits from the current location revealed by this action, as determined by the World Engine.")
    model_config = ConfigDict(extra="allow")

    # @model_validator(mode='after')
    # def check_duration_and_results_if_invalid(self) -> 'WorldEngineResponse':
    #     if not self.valid_action:
    #         if self.duration != 0.0:
    #             logger.debug(f"WorldEngineResponse: Invalid action returned non-zero duration ({self.duration}). Forcing to 0.0.")
    #             self.duration = 0.0
    #         if self.results:
    #             logger.debug(f"WorldEngineResponse: Invalid action returned non-empty results ({self.results}). Forcing to empty dict.")
    #             self.results = {}
    #     return self

class SimulacraIntentResponse(BaseModel):
    internal_monologue: str
    action_type: str
    target_id: Optional[str] = None
    details: str = ""

# --- World Generator Output Models ---
class GeneratedLocationConnection(BaseModel):
    to_location_id_hint: str
    description: str # e.g., "A sturdy oak door leading to the kitchen."
    # travel_time_estimate_seconds: Optional[int] = None # Can be added if generator provides it

class GeneratedLocationDetail(BaseModel):
    id: str # The ID of the location being defined/detailed
    name: str # Generated descriptive name
    description: str # Generated rich description of this location
    ambient_sound_description: Optional[str] = "The typical sounds of such a place."
    ephemeral_objects: List["DiscoveredObject"] = Field(default_factory=list) # Objects within this location
    ephemeral_npcs: List["DiscoveredNPC"] = Field(default_factory=list) # NPCs within this location
    connected_locations: List[GeneratedLocationConnection] = Field(default_factory=list) # Connections *from* this location
    # You can add a 'type_hint' if the generator should specify (e.g., "kitchen", "living_room")
    # type_hint: Optional[str] = None

class WorldGeneratorOutput(BaseModel):
    defined_location: GeneratedLocationDetail # The primary location that was requested to be defined/detailed
    additional_related_locations: List[GeneratedLocationDetail] = Field(default_factory=list) # E.g., other rooms generated alongside the primary one
    connection_update_for_origin: Optional[Dict[str, Any]] = None # If an origin location needs its connections updated to point to defined_location
# --- Narrator Output Models (Added for Pydantic Validation) ---
class DiscoveredObject(BaseModel):
    id: str
    name: str
    description: str
    is_interactive: bool = True
    properties: Dict[str, Any] = Field(default_factory=dict)

class DiscoveredConnection(BaseModel):
    to_location_id_hint: str
    description: str
    travel_time_estimate_seconds: Optional[int] = None

class DiscoveredNPC(BaseModel):
    id: str
    name: str
    description: str
    is_interactive: bool = True # Based on prompt, though example output omits it. Making it default True.

class LocationPlaceholder(BaseModel):
    id: str
    name: str # Conceptual name generated by Narrator
    description: str = "A newly discovered area. Further details will be revealed upon closer observation."
    ephemeral_objects: List[Dict[str, Any]] = Field(default_factory=list)
    ephemeral_npcs: List[Dict[str, Any]] = Field(default_factory=list)
    connected_locations: List[Dict[str, Any]] = Field(default_factory=list)
    # Add any other minimal essential fields a location needs from the start
    # e.g., ambient_sound_description: Optional[str] = "An indistinct background noise."

class NarratorOutput(BaseModel):
    narrative: str